<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark">
    <meta name="supported-color-schemes" content="light dark">

    <title>WinFsp API: winfsp.h &middot; WinFsp</title>

    <link rel="stylesheet" href="../../css/primer.css" />
    <link rel="stylesheet" href="../../css/site.css" />
  </head>
  <body class="bg-white text-gray-dark">

    

    <div id="container" class="container-lg clearfix"><div id="top" class="d-block d-md-none">
          <div class="clearfix bg-gray-light border-bottom p-3">
            <img src="../../logo.png" class="float-left mr-3 auto-invert" style="height:32px;" />
            <h1 class="f2-light text-uppercase float-left">WinFsp</h1>
            <details class="dropdown details-reset details-overlay float-right">
              <summary class="btn-octicon" aria-haspopup="true">
                <img src="../../svg/three-bars.svg" class="auto-invert" />
              </summary>
              <ul class="dropdown-menu dropdown-menu-w">
                <li><a class="dropdown-item" href="../../">Home</a></li><li><a class="dropdown-item" href="../../rel">Download</a></li><li><a class="dropdown-item" href="../../apiref">API Reference</a></li><li><a class="dropdown-item" href="../../doc">Documentation</a></li><li><a class="dropdown-item" href="../../src">Source</a></li>
              </ul>
            </details>
          </div>
        </div>

        <div id="side" class="col-md-3 float-left d-none d-md-block">
          <div class="p-3" style="min-height:100vh">
            <div class="mb-3 text-center">
                <img src="../../logo.png" class="auto-invert" style="width:75%;" />
              </div>
            <h1 class="f1-light text-uppercase text-center mb-3">WinFsp</h1>
            <nav class="SideNav border"><a class="SideNav-item" href="../../" >Home</a>
                <a class="SideNav-item" href="../../rel" >Download</a>
                <a class="SideNav-item" href="../../apiref" >API Reference</a>
                <a class="SideNav-item" href="../../doc" aria-current="page">Documentation</a>
                <nav class="SideNav py-2 pl-3">
                    <a class="SideNav-subItem" href="../../doc/Frequently-Asked-Questions/" >Frequently Asked Questions</a><a class="SideNav-subItem" href="../../doc/Known-File-Systems/" >Known File Systems</a><a class="SideNav-subItem" href="../../doc/Native-API-vs-FUSE/" >Native API vs FUSE</a><a class="SideNav-subItem" href="../../doc/NTFS-Compatibility/" >NTFS Compatibility</a><a class="SideNav-subItem" href="../../doc/Queued-Events/" >Queued Events</a><a class="SideNav-subItem" href="../../doc/SSHFS-Port-Case-Study/" >SSHFS Port Case Study</a><a class="SideNav-subItem" href="../../doc/WinFsp-API-launch.h/" >WinFsp API: launch.h</a><a class="SideNav-subItem" href="../../doc/WinFsp-API-winfsp.h/" aria-current="page">WinFsp API: winfsp.h</a><a class="SideNav-subItem" href="../../doc/WinFsp-as-an-IPC-Mechanism/" >WinFsp as an IPC Mechanism</a><a class="SideNav-subItem" href="../../doc/WinFsp-Container-Support/" >WinFsp Container Support</a><a class="SideNav-subItem" href="../../doc/WinFsp-Debugging-Setup/" >WinFsp Debugging Setup</a><a class="SideNav-subItem" href="../../doc/WinFsp-Design/" >WinFsp Design</a><a class="SideNav-subItem" href="../../doc/WinFsp-Kernel-Mode-File-Systems/" >WinFsp Kernel Mode File Systems</a><a class="SideNav-subItem" href="../../doc/WinFsp-Performance-Testing/" >WinFsp Performance Testing</a><a class="SideNav-subItem" href="../../doc/WinFsp-Rebranding/" >WinFsp Rebranding</a><a class="SideNav-subItem" href="../../doc/WinFsp-Service-Architecture/" >WinFsp Service Architecture</a><a class="SideNav-subItem" href="../../doc/WinFsp-Testing/" >WinFsp Testing</a><a class="SideNav-subItem" href="../../doc/WinFsp-Tutorial/" >WinFsp Tutorial</a>
                  </nav><a class="SideNav-item" href="../../src" >Source</a>
                
            </nav>
          </div>
        </div>

      <div id="main" class="col-12 col-md-9 float-left">
        <div class="p-3 markdown-body" style="min-height:100vh">
          
<h1 id="winfspwinfsph">winfsp/winfsp.h</h1>
<p>WinFsp User Mode API.</p>
<p>In order to use the WinFsp API the user mode file system must include &lt;winfsp/winfsp.h&gt;
and link with the winfsp_x64.dll (or winfsp_x86.dll) library.</p>
<h2 id="file-system">FILE SYSTEM</h2>
<p>A user mode file system is a program that uses the WinFsp API to expose a file system to
Windows. The user mode file system must implement the operations in FSP_FILE_SYSTEM_INTERFACE,
create a file system object using FspFileSystemCreate and start its dispatcher using
FspFileSystemStartDispatcher. At that point it will start receiving file system requests on the
FSP_FILE_SYSTEM_INTERFACE operations.</p>
<h3 id="classes">Classes</h3>
<details>
<summary>
<b>FSP_FILE_SYSTEM_INTERFACE</b> - File system interface.
</summary>
<blockquote>
<br/>
<p><strong>Discussion</strong></p>
<p>The operations in this interface must be implemented by the user mode
file system. Not all operations need be implemented. For example,
a user mode file system that does not wish to support reparse points,
need not implement the reparse point operations.</p>
<p>Most of the operations accept a FileContext parameter. This parameter
has different meanings depending on the value of the FSP_FSCTL_VOLUME_PARAMS
flags UmFileContextIsUserContext2 and UmFileContextIsFullContext.</p>
<p>There are three cases to consider:</p>
<ul>
<li>
<p>When both of these flags are unset (default), the FileContext parameter
represents the file node. The file node is a void pointer (or an integer
that can fit in a pointer) that is used to uniquely identify an open file.
Opening the same file name should always yield the same file node value
for as long as the file with that name remains open anywhere in the system.</p>
</li>
<li>
<p>When the UmFileContextIsUserContext2 is set, the FileContext parameter
represents the file descriptor. The file descriptor is a void pointer (or
an integer that can fit in a pointer) that is used to identify an open
instance of a file. Opening the same file name may yield a different file
descriptor.</p>
</li>
<li>
<p>When the UmFileContextIsFullContext is set, the FileContext parameter
is a pointer to a FSP_FSCTL_TRANSACT_FULL_CONTEXT. This allows a user mode
file system to access the low-level UserContext and UserContext2 values.
The UserContext is used to store the file node and the UserContext2 is
used to store the file descriptor for an open file.</p>
</li>
</ul>
<h4 id="member-functions">Member Functions</h4>
<details>
<summary>
<b>CanDelete</b> - Determine whether a file or directory can be deleted.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">CanDelete</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to test for deletion.</li>
<li><em>FileName</em> - The name of the file or directory to test for deletion.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function tests whether a file or directory can be safely deleted. This function does
not need to perform access checks, but may performs tasks such as check for empty
directories, etc.</p>
<p>This function should <strong>NEVER</strong> delete the file or directory in question. Deletion should
happen during Cleanup with the FspCleanupDelete flag set.</p>
<p>This function gets called when Win32 API&rsquo;s such as DeleteFile or RemoveDirectory are used.
It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE.</p>
<p>NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However
most file systems need only implement the CanDelete operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>Cleanup</li>
<li>SetDelete</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>Cleanup</b> - Cleanup a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">VOID</span> <span class="p">(</span> <span class="o">*</span><span class="n">Cleanup</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to cleanup.</li>
<li><em>FileName</em> - The name of the file or directory to cleanup. Sent only when a Delete is requested.</li>
<li><em>Flags</em> - These flags determine whether the file was modified and whether to delete the file.</li>
</ul>
<p><strong>Discussion</strong></p>
<p>When CreateFile is used to open or create a file the kernel creates a kernel mode file
object (type FILE_OBJECT) and a handle for it, which it returns to user-mode. The handle may
be duplicated (using DuplicateHandle), but all duplicate handles always refer to the same
file object. When all handles for a particular file object get closed (using CloseHandle)
the system sends a Cleanup request to the file system.</p>
<p>There will be a Cleanup operation for every Create or Open operation posted to the user mode
file system. However the Cleanup operation is <strong>not</strong> the final close operation on a file.
The file system must be ready to receive additional operations until close time. This is true
even when the file is being deleted!</p>
<p>The Flags parameter contains information about the cleanup operation:</p>
<ul>
<li>FspCleanupDelete -
An important function of the Cleanup operation is to complete a delete operation. Deleting
a file or directory in Windows is a three-stage process where the file is first opened, then
tested to see if the delete can proceed and if the answer is positive the file is then
deleted during Cleanup.</li>
</ul>
<p>When this flag is set, this is the last outstanding cleanup for this particular file node.</p>
<ul>
<li>
<p>FspCleanupSetAllocationSize -
The NTFS and FAT file systems reset a file&rsquo;s allocation size when they receive the last
outstanding cleanup for a particular file node. User mode file systems that implement
allocation size and wish to duplicate the NTFS and FAT behavior can use this flag.</p>
</li>
<li>
<p>FspCleanupSetArchiveBit -
File systems that support the archive bit should set the file node&rsquo;s archive bit when this
flag is set.</p>
</li>
<li>
<p>FspCleanupSetLastAccessTime, FspCleanupSetLastWriteTime, FspCleanupSetChangeTime - File
systems should set the corresponding file time when each one of these flags is set. Note that
updating the last access time is expensive and a file system may choose to not implement it.</p>
</li>
</ul>
<p>There is no way to report failure of this operation. This is a Windows limitation.</p>
<p>As an optimization a file system may specify the FSP_FSCTL_VOLUME_PARAMS ::
PostCleanupWhenModifiedOnly flag. In this case the FSD will only post Cleanup requests when
the file was modified/deleted.</p>
<p><strong>See Also</strong></p>
<ul>
<li>Close</li>
<li>CanDelete</li>
<li>SetDelete</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>Close</b> - Close a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">VOID</span> <span class="p">(</span> <span class="o">*</span><span class="n">Close</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to be closed.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>Control</b> - Process control code.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Control</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">ControlCode</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">InputBuffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">InputBufferLength</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">OutputBuffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">OutputBufferLength</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to be controled.</li>
<li><em>ControlCode</em> - The control code for the operation. This code must have a DeviceType with bit
0x8000 set and must have a TransferType of METHOD_BUFFERED.</li>
<li><em>InputBuffer</em> - Pointer to a buffer that contains the input data.</li>
<li><em>InputBufferLength</em> - Input data length.</li>
<li><em>OutputBuffer</em> - Pointer to a buffer that will receive the output data.</li>
<li><em>OutputBufferLength</em> - Output data length.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes transferred.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function is called when a program uses the DeviceIoControl API.</p>
</blockquote>
</details>
<details>
<summary>
<b>Create</b> - Create new file or directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Create</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">CreateOptions</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">GrantedAccess</span><span class="p">,</span> 
    <span class="n">UINT32</span> <span class="n">FileAttributes</span><span class="p">,</span>
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">AllocationSize</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="o">*</span><span class="n">PFileContext</span><span class="p">,</span>
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileName</em> - The name of the file or directory to be created.</li>
<li><em>CreateOptions</em> - Create options for this request. This parameter has the same meaning as the
CreateOptions parameter of the NtCreateFile API. User mode file systems should typically
only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a
directory rather than a file. Some file systems may also want to pay attention to the
FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are
typically handled by the FSD component.</li>
<li><em>GrantedAccess</em> - Determines the specific access rights that have been granted for this request. Upon
receiving this call all access checks have been performed and the user mode file system
need not perform any additional checks. However this parameter may be useful to a user
mode file system; for example the WinFsp-FUSE layer uses this parameter to determine
which flags to use in its POSIX open() call.</li>
<li><em>FileAttributes</em> - File attributes to apply to the newly created file or directory.</li>
<li><em>SecurityDescriptor</em> - Security descriptor to apply to the newly created file or directory. This security
descriptor will always be in self-relative format. Its length can be retrieved using the
Windows GetSecurityDescriptorLength API. Will be NULL for named streams.</li>
<li><em>AllocationSize</em> - Allocation size for the newly created file.</li>
<li><em>PFileContext</em> - [out]
Pointer that will receive the file context on successful return from this call.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>CreateEx</b> - Create new file or directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">CreateEx</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">CreateOptions</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">GrantedAccess</span><span class="p">,</span> 
    <span class="n">UINT32</span> <span class="n">FileAttributes</span><span class="p">,</span>
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">AllocationSize</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">ExtraBuffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">ExtraLength</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ExtraBufferIsReparsePoint</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="o">*</span><span class="n">PFileContext</span><span class="p">,</span>
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileName</em> - The name of the file or directory to be created.</li>
<li><em>CreateOptions</em> - Create options for this request. This parameter has the same meaning as the
CreateOptions parameter of the NtCreateFile API. User mode file systems should typically
only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a
directory rather than a file. Some file systems may also want to pay attention to the
FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are
typically handled by the FSD component.</li>
<li><em>GrantedAccess</em> - Determines the specific access rights that have been granted for this request. Upon
receiving this call all access checks have been performed and the user mode file system
need not perform any additional checks. However this parameter may be useful to a user
mode file system; for example the WinFsp-FUSE layer uses this parameter to determine
which flags to use in its POSIX open() call.</li>
<li><em>FileAttributes</em> - File attributes to apply to the newly created file or directory.</li>
<li><em>SecurityDescriptor</em> - Security descriptor to apply to the newly created file or directory. This security
descriptor will always be in self-relative format. Its length can be retrieved using the
Windows GetSecurityDescriptorLength API. Will be NULL for named streams.</li>
<li><em>AllocationSize</em> - Allocation size for the newly created file.</li>
<li><em>ExtraBuffer</em> - Extended attributes or reparse point buffer.</li>
<li><em>ExtraLength</em> - Extended attributes or reparse point buffer length.</li>
<li><em>ExtraBufferIsReparsePoint</em> - FALSE: extra buffer is extended attributes; TRUE: extra buffer is reparse point.</li>
<li><em>PFileContext</em> - [out]
Pointer that will receive the file context on successful return from this call.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function works like Create, except that it also accepts an extra buffer that
may contain extended attributes or a reparse point.</p>
<p>NOTE: If both Create and CreateEx are defined, CreateEx takes precedence.</p>
</blockquote>
</details>
<details>
<summary>
<b>DeleteReparsePoint</b> - Delete reparse point.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">DeleteReparsePoint</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="n">Size</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the reparse point.</li>
<li><em>FileName</em> - The file name of the reparse point.</li>
<li><em>Buffer</em> - Pointer to a buffer that contains the data for this operation.</li>
<li><em>Size</em> - Size of data to write.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>Flush</b> - Flush a file or volume.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Flush</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to be flushed. When NULL the whole volume is being flushed.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc. Used when
flushing file (not volume).</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>Note that the FSD will also flush all file/volume caches prior to invoking this operation.</p>
</blockquote>
</details>
<details>
<summary>
<b>GetDirInfoByName</b> - Get directory information for a single file or directory within a parent directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetDirInfoByName</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_DIR_INFO</span> <span class="o">*</span><span class="n">DirInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the parent directory.</li>
<li><em>FileName</em> - The name of the file or directory to get information for. This name is relative
to the parent directory and is a single path component.</li>
<li><em>DirInfo</em> - [out]
Pointer to a structure that will receive the directory information on successful
return from this call. This information includes the file name, but also file
attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>GetEa</b> - Get extended attributes.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetEa</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">Ea</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">EaLength</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to get extended attributes for.</li>
<li><em>Ea</em> - Extended attributes buffer.</li>
<li><em>EaLength</em> - Extended attributes buffer length.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes transferred.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>SetEa</li>
<li>FspFileSystemAddEa</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>GetFileInfo</b> - Get file or directory information.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetFileInfo</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to get information for.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>GetReparsePoint</b> - Get reparse point.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetReparsePoint</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">PSIZE_T</span> <span class="n">PSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the reparse point.</li>
<li><em>FileName</em> - The file name of the reparse point.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the results of this operation. If
the function returns a symbolic link path, it should not be NULL terminated.</li>
<li><em>PSize</em> - [in,out]
Pointer to the buffer size. On input it contains the size of the buffer.
On output it will contain the actual size of data copied.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>SetReparsePoint</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>GetSecurity</b> - Get file or directory security descriptor.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetSecurity</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="o">*</span><span class="n">PSecurityDescriptorSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to get the security descriptor for.</li>
<li><em>SecurityDescriptor</em> - Pointer to a buffer that will receive the file security descriptor on successful return
from this call. May be NULL.</li>
<li><em>PSecurityDescriptorSize</em> - [in,out]
Pointer to the security descriptor buffer size. On input it contains the size of the
security descriptor buffer. On output it will contain the actual size of the security
descriptor copied into the security descriptor buffer. Cannot be NULL.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>GetSecurityByName</b> - Get file or directory attributes and security descriptor given a file name.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetSecurityByName</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PUINT32</span> <span class="n">PFileAttributes</span><span class="cm">/* or ReparsePointIndex */</span><span class="p">,</span> 
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="o">*</span><span class="n">PSecurityDescriptorSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileName</em> - The name of the file or directory to get the attributes and security descriptor for.</li>
<li><em>PFileAttributes</em> - Pointer to a memory location that will receive the file attributes on successful return
from this call. May be NULL.</li>
</ul>
<p>If this call returns STATUS_REPARSE, the file system MAY place here the index of the
first reparse point within FileName. The file system MAY also leave this at its default
value of 0.</p>
<ul>
<li><em>SecurityDescriptor</em> - Pointer to a buffer that will receive the file security descriptor on successful return
from this call. May be NULL.</li>
<li><em>PSecurityDescriptorSize</em> - [in,out]
Pointer to the security descriptor buffer size. On input it contains the size of the
security descriptor buffer. On output it will contain the actual size of the security
descriptor copied into the security descriptor buffer. May be NULL.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS, STATUS_REPARSE or error code.</p>
<p>STATUS_REPARSE should be returned by file systems that support reparse points when
they encounter a FileName that contains reparse points anywhere but the final path
component.</p>
</blockquote>
</details>
<details>
<summary>
<b>GetStreamInfo</b> - Get named streams information.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetStreamInfo</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span> 
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to get stream information for.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the stream information.</li>
<li><em>Length</em> - Length of buffer.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes stored.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>FspFileSystemAddStreamInfo</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>GetVolumeInfo</b> - Get volume information.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">GetVolumeInfo</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_VOLUME_INFO</span> <span class="o">*</span><span class="n">VolumeInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>VolumeInfo</em> - [out]
Pointer to a structure that will receive the volume information on successful return
from this call.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>Open</b> - Open a file or directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Open</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">CreateOptions</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">GrantedAccess</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="o">*</span><span class="n">PFileContext</span><span class="p">,</span>
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileName</em> - The name of the file or directory to be opened.</li>
<li><em>CreateOptions</em> - Create options for this request. This parameter has the same meaning as the
CreateOptions parameter of the NtCreateFile API. User mode file systems typically
do not need to do anything special with respect to this parameter. Some file systems may
also want to pay attention to the FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH
flags, although these are typically handled by the FSD component.</li>
<li><em>GrantedAccess</em> - Determines the specific access rights that have been granted for this request. Upon
receiving this call all access checks have been performed and the user mode file system
need not perform any additional checks. However this parameter may be useful to a user
mode file system; for example the WinFsp-FUSE layer uses this parameter to determine
which flags to use in its POSIX open() call.</li>
<li><em>PFileContext</em> - [out]
Pointer that will receive the file context on successful return from this call.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>Overwrite</b> - Overwrite a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Overwrite</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">FileAttributes</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ReplaceFileAttributes</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">AllocationSize</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to overwrite.</li>
<li><em>FileAttributes</em> - File attributes to apply to the overwritten file.</li>
<li><em>ReplaceFileAttributes</em> - When TRUE the existing file attributes should be replaced with the new ones.
When FALSE the existing file attributes should be merged (or&rsquo;ed) with the new ones.</li>
<li><em>AllocationSize</em> - Allocation size for the overwritten file.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>OverwriteEx</b> - Overwrite a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">OverwriteEx</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">FileAttributes</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ReplaceFileAttributes</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">AllocationSize</span><span class="p">,</span> 
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">Ea</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">EaLength</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to overwrite.</li>
<li><em>FileAttributes</em> - File attributes to apply to the overwritten file.</li>
<li><em>ReplaceFileAttributes</em> - When TRUE the existing file attributes should be replaced with the new ones.
When FALSE the existing file attributes should be merged (or&rsquo;ed) with the new ones.</li>
<li><em>AllocationSize</em> - Allocation size for the overwritten file.</li>
<li><em>Ea</em> - Extended attributes buffer.</li>
<li><em>EaLength</em> - Extended attributes buffer length.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function works like Overwrite, except that it also accepts EA (extended attributes).</p>
<p>NOTE: If both Overwrite and OverwriteEx are defined, OverwriteEx takes precedence.</p>
</blockquote>
</details>
<details>
<summary>
<b>Read</b> - Read a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Read</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">Offset</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span> 
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to be read.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the results of the read operation.</li>
<li><em>Offset</em> - Offset within the file to read from.</li>
<li><em>Length</em> - Length of data to read.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes read.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous
operation.</p>
</blockquote>
</details>
<details>
<summary>
<b>ReadDirectory</b> - Read a directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">ReadDirectory</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">Marker</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the directory to be read.</li>
<li><em>Pattern</em> - The pattern to match against files in this directory. Can be NULL. The file system
can choose to ignore this parameter as the FSD will always perform its own pattern
matching on the returned results.</li>
<li><em>Marker</em> - A file name that marks where in the directory to start reading. Files with names
that are greater than (not equal to) this marker (in the directory order determined
by the file system) should be returned. Can be NULL.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the results of the read operation.</li>
<li><em>Length</em> - Length of data to read.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes read.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous
operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>FspFileSystemAddDirInfo</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>Rename</b> - Renames a file or directory.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Rename</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">NewFileName</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ReplaceIfExists</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to be renamed.</li>
<li><em>FileName</em> - The current name of the file or directory to rename.</li>
<li><em>NewFileName</em> - The new name for the file or directory.</li>
<li><em>ReplaceIfExists</em> - Whether to replace a file that already exists at NewFileName.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>The kernel mode FSD provides certain guarantees prior to posting a rename operation:</p>
<ul>
<li>
<p>A file cannot be renamed if a file with the same name exists and has open handles.</p>
</li>
<li>
<p>A directory cannot be renamed if it or any of its subdirectories contains a file that
has open handles.</p>
</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>ResolveReparsePoints</b> - Resolve reparse points.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">ResolveReparsePoints</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">ReparsePointIndex</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ResolveLastPathComponent</span><span class="p">,</span> 
    <span class="n">PIO_STATUS_BLOCK</span> <span class="n">PIoStatus</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">PSIZE_T</span> <span class="n">PSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileName</em> - The name of the file or directory to have its reparse points resolved.</li>
<li><em>ReparsePointIndex</em> - The index of the first reparse point within FileName.</li>
<li><em>ResolveLastPathComponent</em> - If FALSE, the last path component of FileName should not be resolved, even
if it is a reparse point that can be resolved. If TRUE, all path components
should be resolved if possible.</li>
<li><em>PIoStatus</em> - Pointer to storage that will receive the status to return to the FSD. When
this function succeeds it must set PIoStatus-&gt;Status to STATUS_REPARSE and
PIoStatus-&gt;Information to either IO_REPARSE or the reparse tag.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or
reparse data (reparse tag). If the function returns a file name, it should
not be NULL terminated.</li>
<li><em>PSize</em> - [in,out]
Pointer to the buffer size. On input it contains the size of the buffer.
On output it will contain the actual size of data copied.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_REPARSE or error code.</p>
<p><strong>Discussion</strong></p>
<p>Reparse points are a general mechanism for attaching special behavior to files.
A file or directory can contain a reparse point. A reparse point is data that has
special meaning to the file system, Windows or user applications. For example, NTFS
and Windows use reparse points to implement symbolic links. As another example,
a particular file system may use reparse points to emulate UNIX FIFO&rsquo;s.</p>
<p>This function is expected to resolve as many reparse points as possible. If a reparse
point is encountered that is not understood by the file system further reparse point
resolution should stop; the reparse point data should be returned to the FSD with status
STATUS_REPARSE/reparse-tag. If a reparse point (symbolic link) is encountered that is
understood by the file system but points outside it, the reparse point should be
resolved, but further reparse point resolution should stop; the resolved file name
should be returned to the FSD with status STATUS_REPARSE/IO_REPARSE.</p>
</blockquote>
</details>
<details>
<summary>
<b>SetBasicInfo</b> - Set file or directory basic information.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetBasicInfo</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">FileAttributes</span><span class="p">,</span> 
    <span class="n">UINT64</span> <span class="n">CreationTime</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">LastAccessTime</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">LastWriteTime</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">ChangeTime</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to set information for.</li>
<li><em>FileAttributes</em> - File attributes to apply to the file or directory. If the value INVALID_FILE_ATTRIBUTES
is sent, the file attributes should not be changed.</li>
<li><em>CreationTime</em> - Creation time to apply to the file or directory. If the value 0 is sent, the creation
time should not be changed.</li>
<li><em>LastAccessTime</em> - Last access time to apply to the file or directory. If the value 0 is sent, the last
access time should not be changed.</li>
<li><em>LastWriteTime</em> - Last write time to apply to the file or directory. If the value 0 is sent, the last
write time should not be changed.</li>
<li><em>ChangeTime</em> - Change time to apply to the file or directory. If the value 0 is sent, the change time
should not be changed.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>SetDelete</b> - Set the file delete flag.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetDelete</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">DeleteFile</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to set the delete flag for.</li>
<li><em>FileName</em> - The name of the file or directory to set the delete flag for.</li>
<li><em>DeleteFile</em> - If set to TRUE the FSD indicates that the file will be deleted on Cleanup; otherwise
it will not be deleted. It is legal to receive multiple SetDelete calls for the same
file with different DeleteFile parameters.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function sets a flag to indicates whether the FSD file should delete a file
when it is closed. This function does not need to perform access checks, but may
performs tasks such as check for empty directories, etc.</p>
<p>This function should <strong>NEVER</strong> delete the file or directory in question. Deletion should
happen during Cleanup with the FspCleanupDelete flag set.</p>
<p>This function gets called when Win32 API&rsquo;s such as DeleteFile or RemoveDirectory are used.
It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE.</p>
<p>NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However
most file systems need only implement the CanDelete operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>Cleanup</li>
<li>CanDelete</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>SetEa</b> - Set extended attributes.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetEa</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">Ea</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">EaLength</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to set extended attributes for.</li>
<li><em>Ea</em> - Extended attributes buffer.</li>
<li><em>EaLength</em> - Extended attributes buffer length.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>GetEa</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>SetFileSize</b> - Set file/allocation size.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetFileSize</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">NewSize</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">SetAllocationSize</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to set the file/allocation size for.</li>
<li><em>NewSize</em> - New file/allocation size to apply to the file.</li>
<li><em>SetAllocationSize</em> - If TRUE, then the allocation size is being set. if FALSE, then the file size is being set.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function is used to change a file&rsquo;s sizes. Windows file systems maintain two kinds
of sizes: the file size is where the End Of File (EOF) is, and the allocation size is the
actual size that a file takes up on the &ldquo;disk&rdquo;.</p>
<p>The rules regarding file/allocation size are:</p>
<ul>
<li>
<p>Allocation size must always be aligned to the allocation unit boundary. The allocation
unit is the product <code>(UINT64)SectorSize \* (UINT64)SectorsPerAllocationUnit</code> from
the FSP_FSCTL_VOLUME_PARAMS structure. The FSD will always send properly aligned allocation
sizes when setting the allocation size.</p>
</li>
<li>
<p>Allocation size is always greater or equal to the file size.</p>
</li>
<li>
<p>A file size of more than the current allocation size will also extend the allocation
size to the next allocation unit boundary.</p>
</li>
<li>
<p>An allocation size of less than the current file size should also truncate the current
file size.</p>
</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>SetReparsePoint</b> - Set reparse point.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetReparsePoint</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="n">Size</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the reparse point.</li>
<li><em>FileName</em> - The file name of the reparse point.</li>
<li><em>Buffer</em> - Pointer to a buffer that contains the data for this operation. If this buffer
contains a symbolic link path, it should not be assumed to be NULL terminated.</li>
<li><em>Size</em> - Size of data to write.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>GetReparsePoint</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>SetSecurity</b> - Set file or directory security descriptor.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetSecurity</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span> 
    <span class="n">SECURITY_INFORMATION</span> <span class="n">SecurityInformation</span><span class="p">,</span>
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">ModificationDescriptor</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file or directory to set the security descriptor for.</li>
<li><em>SecurityInformation</em> - Describes what parts of the file or directory security descriptor should
be modified.</li>
<li><em>ModificationDescriptor</em> - Describes the modifications to apply to the file or directory security descriptor.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>See Also</strong></p>
<ul>
<li>FspSetSecurityDescriptor</li>
<li>FspDeleteSecurityDescriptor</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>SetVolumeLabel</b> - Set volume label.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">SetVolumeLabel</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">VolumeLabel</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_VOLUME_INFO</span> <span class="o">*</span><span class="n">VolumeInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>VolumeLabel</em> - The new label for the volume.</li>
<li><em>VolumeInfo</em> - [out]
Pointer to a structure that will receive the volume information on successful return
from this call.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>Write</b> - Write a file.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">NTSTATUS</span> <span class="p">(</span> <span class="o">*</span><span class="n">Write</span><span class="p">)(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">FileContext</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">UINT64</span> <span class="n">Offset</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span> 
    <span class="n">BOOLEAN</span> <span class="n">WriteToEndOfFile</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ConstrainedIo</span><span class="p">,</span> 
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">,</span>
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system on which this request is posted.</li>
<li><em>FileContext</em> - The file context of the file to be written.</li>
<li><em>Buffer</em> - Pointer to a buffer that contains the data to write.</li>
<li><em>Offset</em> - Offset within the file to write to.</li>
<li><em>Length</em> - Length of data to write.</li>
<li><em>WriteToEndOfFile</em> - When TRUE the file system must write to the current end of file. In this case the Offset
parameter will contain the value -1.</li>
<li><em>ConstrainedIo</em> - When TRUE the file system must not extend the file (i.e. change the file size).</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes written.</li>
<li><em>FileInfo</em> - [out]
Pointer to a structure that will receive the file information on successful return
from this call. This information includes file attributes, file times, etc.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous
operation.</p>
</blockquote>
</details>
</blockquote>
</details>
<h3 id="functions">Functions</h3>
<details>
<summary>
<b>FspDeleteSecurityDescriptor</b> - Delete security descriptor.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspDeleteSecurityDescriptor</span><span class="p">(</span>
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span><span class="p">,</span> 
    <span class="n">NTSTATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">CreateFunc</span><span class="p">)());</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>SecurityDescriptor</em> - The security descriptor to be deleted.</li>
<li><em>CreateFunc</em> - Function used to create the security descriptor. This parameter should be
set to FspSetSecurityDescriptor for the public API.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the SetSecurity operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>SetSecurity</li>
<li>FspSetSecurityDescriptor</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemAddDirInfo</b> - Add directory information to a buffer.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">BOOLEAN</span> <span class="nf">FspFileSystemAddDirInfo</span><span class="p">(</span>
    <span class="n">FSP_FSCTL_DIR_INFO</span> <span class="o">*</span><span class="n">DirInfo</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>DirInfo</em> - The directory information to add. A value of NULL acts as an EOF marker for a ReadDirectory
operation.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the results of the read operation. This should contain
the same value passed to the ReadDirectory Buffer parameter.</li>
<li><em>Length</em> - Length of data to read. This should contain the same value passed to the ReadDirectory
Length parameter.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes read. This should
contain the same value passed to the ReadDirectory PBytesTransferred parameter.
FspFileSystemAddDirInfo uses the value pointed by this parameter to track how much of the
buffer has been used so far.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>TRUE if the directory information was added, FALSE if there was not enough space to add it.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the ReadDirectory operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>ReadDirectory</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemAddEa</b> - Add extended attribute to a buffer.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">BOOLEAN</span> <span class="nf">FspFileSystemAddEa</span><span class="p">(</span>
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">SingleEa</span><span class="p">,</span> 
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">Ea</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">EaLength</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>SingleEa</em> - The extended attribute to add. A value of NULL acts as an EOF marker for a GetEa
operation.</li>
<li><em>Ea</em> - Pointer to a buffer that will receive the extended attribute. This should contain
the same value passed to the GetEa Ea parameter.</li>
<li><em>EaLength</em> - Length of buffer. This should contain the same value passed to the GetEa
EaLength parameter.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes stored. This should
contain the same value passed to the GetEa PBytesTransferred parameter.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>TRUE if the extended attribute was added, FALSE if there was not enough space to add it.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the GetEa operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>GetEa</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemAddStreamInfo</b> - Add named stream information to a buffer.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">BOOLEAN</span> <span class="nf">FspFileSystemAddStreamInfo</span><span class="p">(</span>
    <span class="n">FSP_FSCTL_STREAM_INFO</span> <span class="o">*</span><span class="n">StreamInfo</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">,</span>
    <span class="n">PULONG</span> <span class="n">PBytesTransferred</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>StreamInfo</em> - The stream information to add. A value of NULL acts as an EOF marker for a GetStreamInfo
operation.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the stream information. This should contain
the same value passed to the GetStreamInfo Buffer parameter.</li>
<li><em>Length</em> - Length of buffer. This should contain the same value passed to the GetStreamInfo
Length parameter.</li>
<li><em>PBytesTransferred</em> - [out]
Pointer to a memory location that will receive the actual number of bytes stored. This should
contain the same value passed to the GetStreamInfo PBytesTransferred parameter.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>TRUE if the stream information was added, FALSE if there was not enough space to add it.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the GetStreamInfo operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>GetStreamInfo</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemCanReplaceReparsePoint</b> - Test whether reparse data can be replaced.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemCanReplaceReparsePoint</span><span class="p">(</span> 
    <span class="n">PVOID</span> <span class="n">CurrentReparseData</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="n">CurrentReparseDataSize</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">ReplaceReparseData</span><span class="p">,</span>
    <span class="n">SIZE_T</span> <span class="n">ReplaceReparseDataSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>CurrentReparseData</em> - Pointer to the current reparse data.</li>
<li><em>CurrentReparseDataSize</em> - Pointer to the current reparse data size.</li>
<li><em>ReplaceReparseData</em> - Pointer to the replacement reparse data.</li>
<li><em>ReplaceReparseDataSize</em> - Pointer to the replacement reparse data size.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the SetReparsePoint/DeleteReparsePoint operation
in file systems that support reparse points.</p>
<p><strong>See Also</strong></p>
<ul>
<li>SetReparsePoint</li>
<li>DeleteReparsePoint</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemCreate</b> - Create a file system object.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemCreate</span><span class="p">(</span>
    <span class="n">PWSTR</span> <span class="n">DevicePath</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">FSP_FSCTL_VOLUME_PARAMS</span> <span class="o">*</span><span class="n">VolumeParams</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">FSP_FILE_SYSTEM_INTERFACE</span> <span class="o">*</span><span class="n">Interface</span><span class="p">,</span> 
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">**</span><span class="n">PFileSystem</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>DevicePath</em> - The name of the control device for this file system. This must be either
FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME.</li>
<li><em>VolumeParams</em> - Volume parameters for the newly created file system.</li>
<li><em>Interface</em> - A pointer to the actual operations that actually implement this user mode file system.</li>
<li><em>PFileSystem</em> - [out]
Pointer that will receive the file system object created on successful return from this
call.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemDelete</b> - Delete a file system object.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspFileSystemDelete</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemEnumerateEa</b> - Enumerate extended attributes in a buffer.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemEnumerateEa</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">NTSTATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">EnumerateEa</span><span class="p">)(</span> 
        <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span>
        <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
        <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">SingleEa</span><span class="p">),</span> 
    <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">Ea</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">EaLength</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>EnumerateEa</em> - Pointer to function that receives a single extended attribute. The function
should return STATUS_SUCCESS or an error code if unsuccessful.</li>
<li><em>Context</em> - User context to supply to EnumEa.</li>
<li><em>Ea</em> - Extended attributes buffer.</li>
<li><em>EaLength</em> - Extended attributes buffer length.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code from EnumerateEa.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the CreateEx and SetEa operations in file systems
that support extended attributes.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemFindReparsePoint</b> - Find reparse point in file name.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">BOOLEAN</span> <span class="nf">FspFileSystemFindReparsePoint</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">NTSTATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">GetReparsePointByName</span><span class="p">)(</span> 
        <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span>
        <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
        <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
        <span class="n">BOOLEAN</span> <span class="n">IsDirectory</span><span class="p">,</span>
        <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
        <span class="n">PSIZE_T</span> <span class="n">PSize</span><span class="p">),</span> 
    <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">PUINT32</span> <span class="n">PReparsePointIndex</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>GetReparsePointByName</em> - Pointer to function that can retrieve reparse point information by name. The
FspFileSystemFindReparsePoint will call this function with the Buffer and PSize
arguments set to NULL. The function should return STATUS_SUCCESS if the passed
FileName is a reparse point or STATUS_NOT_A_REPARSE_POINT (or other error code)
otherwise.</li>
<li><em>Context</em> - User context to supply to GetReparsePointByName.</li>
<li><em>FileName</em> - The name of the file or directory.</li>
<li><em>PReparsePointIndex</em> - Pointer to a memory location that will receive the index of the first reparse point
within FileName. A value is only placed in this memory location if the function returns
TRUE. May be NULL.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>TRUE if a reparse point was found, FALSE otherwise.</p>
<p><strong>Discussion</strong></p>
<p>Given a file name this function returns an index to the first path component that is a reparse
point. The function will call the supplied GetReparsePointByName function for every path
component until it finds a reparse point or the whole path is processed.</p>
<p>This is a helper for implementing the GetSecurityByName operation in file systems
that support reparse points.</p>
<p><strong>See Also</strong></p>
<ul>
<li>GetSecurityByName</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemGetEaPackedSize</b> - Get extended attribute "packed" size. This computation matches what NTFS reports.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="n">UINT32</span> <span class="n">FspFileSystemGetEaPackedSize</span><span class="p">(</span>
    <span class="n">PFILE_FULL_EA_INFORMATION</span> <span class="n">SingleEa</span><span class="p">)</span> 
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>SingleEa</em> - The extended attribute to get the size for.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>The packed size of the extended attribute.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemGetOpenFileInfo</b> - Get open information buffer.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="n">FSP_FSCTL_OPEN_FILE_INFO</span> <span class="o">*</span><span class="n">FspFileSystemGetOpenFileInfo</span><span class="p">(</span>
    <span class="n">FSP_FSCTL_FILE_INFO</span> <span class="o">*</span><span class="n">FileInfo</span><span class="p">)</span> 
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileInfo</em> - The FileInfo parameter as passed to Create or Open operation.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>A pointer to the open information buffer for this Create or Open operation.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the Create and Open operations. It cannot be used with
any other operations.</p>
<p>The FileInfo parameter to Create and Open is typed as pointer to FSP_FSCTL_FILE_INFO. The
true type of this parameter is pointer to FSP_FSCTL_OPEN_FILE_INFO. This simple function
converts from one type to the other.</p>
<p>The FSP_FSCTL_OPEN_FILE_INFO type contains a FSP_FSCTL_FILE_INFO as well as the fields
NormalizedName and NormalizedNameSize. These fields can be used for file name normalization.
File name normalization is used to ensure that the FSD and the OS know the correct case
of a newly opened file name.</p>
<p>For case-sensitive file systems this functionality should be ignored. The FSD will always
assume that the normalized file name is the same as the file name used to open the file.</p>
<p>For case-insensitive file systems this functionality may be ignored. In this case the FSD
will assume that the normalized file name is the upper case version of the file name used
to open the file. The file system will work correctly and the only way an application will
be able to tell that the file system does not preserve case in normalized file names is by
issuing a GetFinalPathNameByHandle API call (or NtQueryInformationFile with
FileNameInformation/FileNormalizedNameInformation).</p>
<p>For case-insensitive file systems this functionality may also be used. In this case the
user mode file system may use the NormalizedName and NormalizedNameSize parameters to
report to the FSD the normalized file name. It should be noted that the normalized file
name may only differ in case from the file name used to open the file. The NormalizedName
field will point to a buffer that can receive the normalized file name. The
NormalizedNameSize field will contain the size of the normalized file name buffer. On
completion of the Create or Open operation it should contain the actual size of the
normalized file name copied into the normalized file name buffer. The normalized file name
should not contain a terminating zero.</p>
<p><strong>See Also</strong></p>
<ul>
<li>Create</li>
<li>Open</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemGetOperationContext</b> - Get the current operation context.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">FSP_FILE_SYSTEM_OPERATION_CONTEXT</span> <span class="o">*</span><span class="nf">FspFileSystemGetOperationContext</span><span class="p">(</span>
    <span class="n">VOID</span><span class="p">);</span>  
</code></pre></div><p><strong>Return Value</strong></p>
<p>The current operation context.</p>
<p><strong>Discussion</strong></p>
<p>This function may be used only when servicing one of the FSP_FILE_SYSTEM_INTERFACE operations.
The current operation context is stored in thread local storage. It allows access to the
Request and Response associated with this operation.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemOperationProcessId</b> - Gets the originating process ID.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="n">UINT32</span> <span class="n">FspFileSystemOperationProcessId</span><span class="p">(</span>
    <span class="n">VOID</span><span class="p">)</span> 
</code></pre></div><p><strong>Discussion</strong></p>
<p>Valid only during Create, Open and Rename requests when the target exists.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemPreflight</b> - Check whether creating a file system object is possible.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemPreflight</span><span class="p">(</span>
    <span class="n">PWSTR</span> <span class="n">DevicePath</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">MountPoint</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>DevicePath</em> - The name of the control device for this file system. This must be either
FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME.</li>
<li><em>MountPoint</em> - The mount point for the new file system. A value of NULL means that the file system should
use the next available drive letter counting downwards from Z: as its mount point.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemRemoveMountPoint</b> - Remove the mount point for a file system.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspFileSystemRemoveMountPoint</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemResolveReparsePoints</b> - Resolve reparse points.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemResolveReparsePoints</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">NTSTATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">GetReparsePointByName</span><span class="p">)(</span> 
        <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span>
        <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
        <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
        <span class="n">BOOLEAN</span> <span class="n">IsDirectory</span><span class="p">,</span>
        <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
        <span class="n">PSIZE_T</span> <span class="n">PSize</span><span class="p">),</span> 
    <span class="n">PVOID</span> <span class="n">Context</span><span class="p">,</span> 
    <span class="n">PWSTR</span> <span class="n">FileName</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">ReparsePointIndex</span><span class="p">,</span>
    <span class="n">BOOLEAN</span> <span class="n">ResolveLastPathComponent</span><span class="p">,</span> 
    <span class="n">PIO_STATUS_BLOCK</span> <span class="n">PIoStatus</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">PSIZE_T</span> <span class="n">PSize</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>GetReparsePointByName</em> - Pointer to function that can retrieve reparse point information by name. The function
should return STATUS_SUCCESS if the passed FileName is a reparse point or
STATUS_NOT_A_REPARSE_POINT (or other error code) otherwise.</li>
<li><em>Context</em> - User context to supply to GetReparsePointByName.</li>
<li><em>FileName</em> - The name of the file or directory to have its reparse points resolved.</li>
<li><em>ReparsePointIndex</em> - The index of the first reparse point within FileName.</li>
<li><em>ResolveLastPathComponent</em> - If FALSE, the last path component of FileName should not be resolved, even
if it is a reparse point that can be resolved. If TRUE, all path components
should be resolved if possible.</li>
<li><em>PIoStatus</em> - Pointer to storage that will receive the status to return to the FSD. When
this function succeeds it must set PIoStatus-&gt;Status to STATUS_REPARSE and
PIoStatus-&gt;Information to either IO_REPARSE or the reparse tag.</li>
<li><em>Buffer</em> - Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or
reparse data (reparse tag). If the function returns a file name, it should
not be NULL terminated.</li>
<li><em>PSize</em> - [in,out]
Pointer to the buffer size. On input it contains the size of the buffer.
On output it will contain the actual size of data copied.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_REPARSE or error code.</p>
<p><strong>Discussion</strong></p>
<p>Given a file name (and an index where to start resolving) this function will attempt to
resolve as many reparse points as possible. The function will call the supplied
GetReparsePointByName function for every path component until it resolves the reparse points
or the whole path is processed.</p>
<p>This is a helper for implementing the ResolveReparsePoints operation in file systems
that support reparse points.</p>
<p><strong>See Also</strong></p>
<ul>
<li>ResolveReparsePoints</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemSendResponse</b> - Send a response to the FSD.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspFileSystemSendResponse</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">FSP_FSCTL_TRANSACT_RSP</span> <span class="o">*</span><span class="n">Response</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>Response</em> - The response buffer.</li>
</ul>
<p><strong>Discussion</strong></p>
<p>This call is not required when the user mode file system performs synchronous processing of
requests. It is possible however for the following FSP_FILE_SYSTEM_INTERFACE operations to be
processed asynchronously:</p>
<ul>
<li>
<p>Read</p>
</li>
<li>
<p>Write</p>
</li>
<li>
<p>ReadDirectory</p>
</li>
</ul>
<p>These operations are allowed to return STATUS_PENDING to postpone sending a response to the FSD.
At a later time the file system can use FspFileSystemSendResponse to send the response.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemSetMountPoint</b> - Set the mount point for a file system.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemSetMountPoint</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">MountPoint</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>MountPoint</em> - The mount point for the new file system. A value of NULL means that the file system should
use the next available drive letter counting downwards from Z: as its mount point.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function supports drive letters (X:) or directories as mount points:</p>
<ul>
<li>
<p>Drive letters: Refer to the documentation of the DefineDosDevice Windows API
to better understand how they are created.</p>
</li>
<li>
<p>Directories: They can be used as mount points for disk based file systems. They cannot
be used for network file systems. This is a limitation that Windows imposes on junctions.</p>
</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemSetOperationGuardStrategy</b> - Set file system locking strategy.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="n">VOID</span> <span class="n">FspFileSystemSetOperationGuardStrategy</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span> 
    <span class="n">FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY</span> <span class="n">GuardStrategy</span><span class="p">)</span> 
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>GuardStrategy</em> - The locking (guard) strategy.</li>
</ul>
<p><strong>See Also</strong></p>
<ul>
<li>FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemStartDispatcher</b> - Start the file system dispatcher.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspFileSystemStartDispatcher</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">ThreadCount</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
<li><em>ThreadCount</em> - The number of threads for the file system dispatcher. A value of 0 will create a default
number of threads and should be chosen in most cases.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>The file system dispatcher is used to dispatch operations posted by the FSD to the user mode
file system. Once this call starts executing the user mode file system will start receiving
file system requests from the kernel.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspFileSystemStopDispatcher</b> - Stop the file system dispatcher.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspFileSystemStopDispatcher</span><span class="p">(</span>
    <span class="n">FSP_FILE_SYSTEM</span> <span class="o">*</span><span class="n">FileSystem</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>FileSystem</em> - The file system object.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspSetSecurityDescriptor</b> - Modify security descriptor.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspSetSecurityDescriptor</span><span class="p">(</span> 
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">InputDescriptor</span><span class="p">,</span> 
    <span class="n">SECURITY_INFORMATION</span> <span class="n">SecurityInformation</span><span class="p">,</span> 
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="n">ModificationDescriptor</span><span class="p">,</span> 
    <span class="n">PSECURITY_DESCRIPTOR</span> <span class="o">*</span><span class="n">PSecurityDescriptor</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>InputDescriptor</em> - The input security descriptor to be modified.</li>
<li><em>SecurityInformation</em> - Describes what parts of the InputDescriptor should be modified. This should contain
the same value passed to the SetSecurity SecurityInformation parameter.</li>
<li><em>ModificationDescriptor</em> - Describes the modifications to apply to the InputDescriptor. This should contain
the same value passed to the SetSecurity ModificationDescriptor parameter.</li>
<li><em>PSecurityDescriptor</em> - [out]
Pointer to a memory location that will receive the resulting security descriptor.
This security descriptor can be later freed using FspDeleteSecurityDescriptor.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This is a helper for implementing the SetSecurity operation.</p>
<p><strong>See Also</strong></p>
<ul>
<li>SetSecurity</li>
<li>FspDeleteSecurityDescriptor</li>
</ul>
</blockquote>
</details>
<h3 id="typedefs">Typedefs</h3>
<details>
<summary>
<b>FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY</b> - User mode file system locking strategy.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> 
    <span class="n">FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FINE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
    <span class="n">FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_COARSE</span><span class="p">,</span> 
<span class="p">}</span> <span class="n">FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY</span><span class="p">;</span>  
</code></pre></div><p><strong>Discussion</strong></p>
<p>Two concurrency models are provided:</p>
<ol>
<li>A fine-grained concurrency model where file system NAMESPACE accesses
are guarded using an exclusive-shared (read-write) lock. File I/O is not
guarded and concurrent reads/writes/etc. are possible. [Note that the FSD
will still apply an exclusive-shared lock PER INDIVIDUAL FILE, but it will
not limit I/O operations for different files.]
The fine-grained concurrency model applies the exclusive-shared lock as
follows:</li>
</ol>
<ul>
<li>
<p>EXCL: SetVolumeLabel, Flush(Volume),
Create, Cleanup(Delete), SetInformation(Rename)</p>
</li>
<li>
<p>SHRD: GetVolumeInfo, Open, SetInformation(Disposition), ReadDirectory</p>
</li>
<li>
<p>NONE: all other operations</p>
</li>
</ul>
<ol start="2">
<li>A coarse-grained concurrency model where all file system accesses are
guarded by a mutually exclusive lock.</li>
</ol>
<p><strong>See Also</strong></p>
<ul>
<li>FspFileSystemSetOperationGuardStrategy</li>
</ul>
</blockquote>
</details>
<h2 id="service-framework">SERVICE FRAMEWORK</h2>
<p>User mode file systems typically are run as Windows services. WinFsp provides an API to make
the creation of Windows services easier. This API is provided for convenience and is not
necessary to expose a user mode file system to Windows.</p>
<h3 id="functions-1">Functions</h3>
<details>
<summary>
<b>FspServiceAcceptControl</b> - Configure the control codes that a service accepts.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceAcceptControl</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Control</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
<li><em>Control</em> - The control codes to accept. Note that the SERVICE_ACCEPT_PAUSE_CONTINUE code is silently
ignored.</li>
</ul>
<p><strong>Discussion</strong></p>
<p>This API should be used prior to Start operations.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceAllowConsoleMode</b> - Allow a service to run in console mode.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceAllowConsoleMode</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
</ul>
<p><strong>Discussion</strong></p>
<p>A service that is run in console mode runs with a console attached and outside the control of
the Service Control Manager. This is useful for debugging and testing a service during
development.</p>
<p>User mode file systems that wish to use the WinFsp Launcher functionality must also use this
call. The WinFsp Launcher is a Windows service that can be configured to launch and manage
multiple instances of a user mode file system.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceContextCheck</b> - Check if the supplied token is from the service context.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspServiceContextCheck</span><span class="p">(</span>
    <span class="n">HANDLE</span> <span class="n">Token</span><span class="p">,</span>
    <span class="n">PBOOLEAN</span> <span class="n">PIsLocalSystem</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Token</em> - Token to check. Pass NULL to check the current process token.</li>
<li><em>PIsLocalSystem</em> - Pointer to a boolean that will receive a TRUE value if the token belongs to LocalSystem
and FALSE otherwise. May be NULL.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS if the token is from the service context. STATUS_ACCESS_DENIED if it is not.
Other error codes are possible.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceCreate</b> - Create a service object.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspServiceCreate</span><span class="p">(</span>
    <span class="n">PWSTR</span> <span class="n">ServiceName</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_START</span> <span class="o">*</span><span class="n">OnStart</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_STOP</span> <span class="o">*</span><span class="n">OnStop</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_CONTROL</span> <span class="o">*</span><span class="n">OnControl</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE</span> <span class="o">**</span><span class="n">PService</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>ServiceName</em> - The name of the service.</li>
<li><em>OnStart</em> - Function to call when the service starts.</li>
<li><em>OnStop</em> - Function to call when the service stops.</li>
<li><em>OnControl</em> - Function to call when the service receives a service control code.</li>
<li><em>PService</em> - [out]
Pointer that will receive the service object created on successful return from this
call.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceDelete</b> - Delete a service object.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceDelete</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceGetExitCode</b> - Get the service process exit code.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">ULONG</span> <span class="nf">FspServiceGetExitCode</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>Service process exit code.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceIsInteractive</b> - Determine if the current process is running in user interactive mode.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">BOOLEAN</span> <span class="nf">FspServiceIsInteractive</span><span class="p">(</span>
    <span class="n">VOID</span><span class="p">);</span>  
</code></pre></div><p><strong>Return Value</strong></p>
<p>TRUE if the process is running in running user interactive mode.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceLog</b> - Log a service message.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceLog</span><span class="p">(</span>
    <span class="n">ULONG</span> <span class="n">Type</span><span class="p">,</span>
    <span class="n">PWSTR</span> <span class="n">Format</span><span class="p">,</span>
    <span class="p">...);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Type</em> - One of EVENTLOG_INFORMATION_TYPE, EVENTLOG_WARNING_TYPE, EVENTLOG_ERROR_TYPE.</li>
<li><em>Format</em> - Format specification. This function uses the Windows wsprintf API for formatting. Refer to
that API&rsquo;s documentation for details on the format specification.</li>
</ul>
<p><strong>Discussion</strong></p>
<p>This function can be used to log an arbitrary message to the Windows Event Log or to the current
console if running in user interactive mode.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceLoop</b> - Run a service main loop.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">NTSTATUS</span> <span class="nf">FspServiceLoop</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>This function starts and runs a service. It executes the Windows StartServiceCtrlDispatcher API
to connect the service process to the Service Control Manager. If the Service Control Manager is
not available (and console mode is allowed) it will enter console mode.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceRequestTime</b> - Request additional time from the Service Control Manager.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceRequestTime</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Time</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
<li><em>Time</em> - Additional time (in milliseconds).</li>
</ul>
<p><strong>Discussion</strong></p>
<p>This API should be used during Start and Stop operations only.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceRunEx</b> - Run a service.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">ULONG</span> <span class="nf">FspServiceRunEx</span><span class="p">(</span>
    <span class="n">PWSTR</span> <span class="n">ServiceName</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_START</span> <span class="o">*</span><span class="n">OnStart</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_STOP</span> <span class="o">*</span><span class="n">OnStop</span><span class="p">,</span> 
    <span class="n">FSP_SERVICE_CONTROL</span> <span class="o">*</span><span class="n">OnControl</span><span class="p">,</span> 
    <span class="n">PVOID</span> <span class="n">UserContext</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>ServiceName</em> - The name of the service.</li>
<li><em>OnStart</em> - Function to call when the service starts.</li>
<li><em>OnStop</em> - Function to call when the service stops.</li>
<li><em>OnControl</em> - Function to call when the service receives a service control code.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>Service process exit code.</p>
<p><strong>Discussion</strong></p>
<p>This function wraps calls to FspServiceCreate, FspServiceLoop and FspServiceDelete to create,
run and delete a service. It is intended to be used from a service&rsquo;s main/wmain function.</p>
<p>This function runs a service with console mode allowed.</p>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceSetExitCode</b> - Set the service process exit code.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceSetExitCode</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">ExitCode</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
<li><em>ExitCode</em> - Service process exit code.</li>
</ul>
</blockquote>
</details>
<details>
<summary>
<b>FspServiceStop</b> - Stops a running service.
</summary>
<blockquote>
<br/>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FSP_API</span> <span class="n">VOID</span> <span class="nf">FspServiceStop</span><span class="p">(</span>
    <span class="n">FSP_SERVICE</span> <span class="o">*</span><span class="n">Service</span><span class="p">);</span>  
</code></pre></div><p><strong>Parameters</strong></p>
<ul>
<li><em>Service</em> - The service object.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>STATUS_SUCCESS or error code.</p>
<p><strong>Discussion</strong></p>
<p>Stopping a service usually happens when the Service Control Manager instructs the service to
stop. In some situations (e.g. fatal errors) the service may wish to stop itself. It can do so
in a clean manner by calling this function.</p>
</blockquote>
</details>
<br/>
<p align="center">
<sub>
Copyright © 2015-2020 Bill Zissimopoulos
<br/>
Generated with <a href="https://github.com/billziss-gh/prettydoc">prettydoc</a>
</sub>
</p>

</div>
      </div>
  
    </div>

  </body>
</html>
